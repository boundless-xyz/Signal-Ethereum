use std::{io::Write, path::PathBuf};
use z_core::{verify, GuestContext, HostContext, HostStateReader, Input, SszStateReader};

use beacon_api_client::{BlockId, StateId};
use beacon_client::{EventKind, EventTopic};
use clap::Parser;
use ethereum_consensus::electra::{compute_epoch_at_slot, Checkpoint, Context, Epoch};
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::BEACON_GUEST_ELF;
use risc0_zkvm::{default_executor, ExecutorEnv};
mod beacon_client;

use futures::StreamExt;
use ssz_rs::prelude::*;
use tracing::{debug, error, info, warn};
use url::Url;

const DATA_PATH: &str = "./data/sepolia/states/";
const HTTP_CACHE: &str = "./data/http/";

/// CLI for generating and submitting ZKasper proofs
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// Trusted epoch
    #[clap(long)]
    trusted_epoch: Option<Epoch>,

    #[clap(long, required = true)]
    beacon_api: String,

    #[clap(subcommand)]
    command: Command,
}

/// Subcommands of the publisher CLI.
#[derive(Parser, Debug)]
enum Command {
    /// Runs FFG verification in R0VM Executor
    #[clap(name = "exec")]
    Exec,
    /// Runs FFG verification in the host
    #[clap(name = "native-exec")]
    NativeExec,
    #[clap(name = "daemon")]
    Daemon,
}

#[tokio::main]
async fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();
    let context = Context::for_sepolia();

    let mut reader = HostStateReader::load_all_from_file(DATA_PATH, context.clone()).unwrap();

    let args = Args::parse();

    let url = args.beacon_api;
    let beacon_client =
        beacon_client::BeaconClient::new_with_cache(Url::parse(&url).unwrap(), HTTP_CACHE).unwrap();

    match args.command {
        Command::Exec => {
            let trusted_epoch = args.trusted_epoch.expect("trusted_epoch is required");
            let trusted_checkpoint = Checkpoint {
                epoch: trusted_epoch,
                // TODO(ec2): this should be the root of the block at the trusted checkpoint
                root: Default::default(),
            };

            let input = compute_next_candidate(&beacon_client, trusted_checkpoint, &reader).await;
            reader
                .build_validator_cache(input.trusted_checkpoint.epoch)
                .unwrap();
            let host_cache: Vec<z_core::ValidatorInfo> = reader.validator_cache.clone();

            let mut reader = reader.track(input.trusted_checkpoint.epoch);
            let context: HostContext = context.into();
            if verify(&mut reader, input.clone(), &context) {
                info!("FFG Verification passed with HostStateReader");
            } else {
                error!("FFG Verification failed with HostStateReader");
            }
            let mut ssz_reader = reader.build();

            ssz_reader.verify_and_cache(*input.trusted_checkpoint_state_root);

            assert!(
                host_cache == ssz_reader.cache.validators,
                "caches should be equal"
            );

            if verify(&mut ssz_reader, input.clone(), &context) {
                info!("FFG Verification passed with SszStateReader");
            } else {
                error!("FFG Verification failed with SszStateReader");
            }

            info!("Running FFG Verification in R0VM");
            let journal = execute_guest_program(ssz_reader, input, GuestContext);
            info!("Journal: {:?}", journal);
        }
        Command::NativeExec => {
            let trusted_epoch = args.trusted_epoch.expect("trusted_epoch is required");
            let trusted_checkpoint = Checkpoint {
                epoch: trusted_epoch,
                // TODO(ec2): this should be the root of the block at the trusted checkpoint
                root: Default::default(),
            };

            let input = compute_next_candidate(&beacon_client, trusted_checkpoint, &reader).await;
            reader
                .build_validator_cache(input.trusted_checkpoint.epoch)
                .unwrap();
            let host_cache: Vec<z_core::ValidatorInfo> = reader.validator_cache.clone();

            let mut reader = reader.track(input.trusted_checkpoint.epoch);
            let context: HostContext = context.into();
            if verify(&mut reader, input.clone(), &context) {
                info!("FFG Verification passed with HostStateReader");
            } else {
                error!("FFG Verification failed with HostStateReader");
            }

            let mut ssz_reader = reader.build();

            ssz_reader.verify_and_cache(*input.trusted_checkpoint_state_root);

            assert!(
                host_cache == ssz_reader.cache.validators,
                "caches should be equal"
            );

            if verify(&mut ssz_reader, input.clone(), &context) {
                info!("FFG Verification passed with SszStateReader");
            } else {
                error!("FFG Verification failed with SszStateReader");
            }
        }
        Command::Daemon => {
            daemon(&beacon_client).await;
        }
    }
}

fn execute_guest_program(
    ssz_reader: SszStateReader,
    input: Input,
    context: GuestContext,
) -> Vec<u8> {
    info!("Executing guest program");
    let env = ExecutorEnv::builder()
        .write_frame(&bincode::serialize(&ssz_reader).unwrap())
        .write_frame(&bincode::serialize(&input).unwrap())
        .write_frame(&bincode::serialize(&context).unwrap())
        .build()
        .unwrap();
    let executor = default_executor();
    let session_info = executor
        .execute(env, BEACON_GUEST_ELF)
        .expect("failed to execute guest program");
    info!("{} user cycles executed.", session_info.cycles());
    session_info.journal.bytes
}

async fn compute_next_candidate(
    beacon_client: &beacon_client::BeaconClient,
    trusted_checkpoint: Checkpoint,
    reader: &HostStateReader,
) -> Input {
    let trusted_state = reader
        .get_beacon_state_by_epoch(trusted_checkpoint.epoch)
        .expect("trusted state should exist");
    info!(
        "Trusted State epoch: {}, slot: {}",
        trusted_checkpoint.epoch,
        trusted_state.slot()
    );

    // Get the next state where theres a the states finalized checkpoint epoch is larger than the trusted_state
    let next_state = (trusted_checkpoint.epoch..).find_map(|epoch| {
        if let Some(state) = reader.get_beacon_state_by_epoch(epoch) {
            if state.finalized_checkpoint().epoch > trusted_checkpoint.epoch {
                return Some(state);
            }
        }
        None
    });

    let next_state = next_state.expect("Next state should exist");
    info!(
        "Found new Candidate Checkpoint: {:?} at epoch: {}",
        next_state.finalized_checkpoint(),
        compute_epoch_at_slot(next_state.slot(), &reader.context)
    );

    // Sanity check to make sure we have this saved
    reader
        .get_beacon_state_by_epoch(next_state.finalized_checkpoint().epoch)
        .expect("Candidate state should exist");
    info!("Get all blocks from trusted checkpoint to where candidate checkpoint gets finalized");

    let mut blocks = Vec::new();
    for slot in trusted_state.slot()..=next_state.slot() {
        let block = beacon_client.get_block(BlockId::Slot(slot)).await;
        match block {
            Ok(block) => blocks.push(block),
            Err(e) => warn!("Failed to get block {}: {}", slot, e),
        }
    }

    let attestations = blocks
        .iter()
        .flat_map(|b| match b.body() {
            ethereum_consensus::types::BeaconBlockBodyRef::Electra(body) => {
                body.attestations.iter().cloned().collect::<Vec<_>>()
            }
            _ => unimplemented!("Electra Only!"),
        })
        .collect::<Vec<_>>();

    info!("Got {} attestations", attestations.len());
    reader.save_to_files(DATA_PATH).unwrap();

    Input {
        trusted_checkpoint: trusted_checkpoint.into(),
        candidate_checkpoint: next_state.finalized_checkpoint().clone().into(),
        attestations: attestations.into_iter().map(Into::into).collect(),
        trusted_checkpoint_state_root: trusted_state.hash_tree_root().unwrap(),
    }
}

async fn daemon(beacon_client: &beacon_client::BeaconClient) {
    let head = beacon_client.get_block(BlockId::Head).await.unwrap();
    info!("Current Chain Head Block: {:?}", head.slot());

    let cp = beacon_client
        .get_finality_checkpoints(StateId::Head)
        .await
        .unwrap();
    info!("Previous Justified Checkpoint: {:?}", cp.previous_justified);
    info!("Current Justified Checkpoint: {:?}", cp.current_justified);
    info!("Current Finalize Checkpoint: {:?}", cp.finalized);

    info!("Fetch Current Finalized Checkpoint Beacon State");

    let state_bytes = if let Ok(mut file) = open_beacon_state_file(cp.finalized.epoch) {
        let mut state_bytes = Vec::new();
        std::io::Read::read_to_end(&mut file, &mut state_bytes).unwrap();
        state_bytes
    } else {
        info!("Fetching Finalized Beacon from API");
        let block = beacon_client
            .get_block_header(BlockId::Root(cp.finalized.root))
            .await
            .unwrap();
        let s = beacon_client
            .get_beacon_state(StateId::Root(block.message.state_root))
            .await
            .unwrap();

        let state_bytes = ssz_rs::serialize(&s).unwrap();
        save_beacon_state_to_file(cp.finalized.epoch, &state_bytes).unwrap();
        state_bytes
    };

    let b: z_core::mainnet::BeaconState = ssz_rs::deserialize(&state_bytes).unwrap();

    info!("Beacon State Fork Version: {:?}", b.fork());

    let mut event_stream = beacon_client
        .get_events(&[EventTopic::Head, EventTopic::FinalizedCheckpoint])
        .await
        .unwrap();

    info!("event stream started");
    while let Some(event) = event_stream.next().await {
        match event {
            Ok(EventKind::Head(h)) => {
                info!(
                    "New Head at slot: {}, state: {}, epoch_transition {}",
                    h.slot, h.state, h.epoch_transition
                );
            }
            Ok(EventKind::FinalizedCheckpoint(cp)) => {
                info!(
                    "New finalized cp epoch: {}, block: {}, state: {}",
                    cp.epoch, cp.block, cp.state
                );
                let s = beacon_client
                    .get_beacon_state(StateId::Root(cp.state))
                    .await
                    .unwrap();
                save_beacon_state_to_file(cp.epoch, &ssz_rs::serialize(&s).unwrap()).unwrap();
            }
            Err(e) => {
                warn!("Error: {:?}", e);
            }
            _ => {
                warn!("Unknown event: {:?}", event);
            }
        }
    }
}
#[tracing::instrument(fields(epoch = %epoch))]
fn open_beacon_state_file(epoch: u64) -> std::io::Result<std::fs::File> {
    debug!("loading beacon state from disk");
    let file_path = format!("{DATA_PATH}{}_beacon_state.ssz", epoch);
    std::fs::File::open(file_path)
}

#[tracing::instrument(skip(state_bytes), fields(epoch = %epoch))]
fn save_beacon_state_to_file(epoch: u64, state_bytes: &[u8]) -> std::io::Result<()> {
    debug!("saving beacon state to disk");
    let path = PathBuf::from(DATA_PATH);
    std::fs::create_dir_all(&path)?;
    let file_path = format!("{DATA_PATH}{}_beacon_state.ssz", epoch);
    let mut file = std::fs::File::create_new(file_path)?;
    file.write_all(state_bytes)?;
    Ok(())
}
